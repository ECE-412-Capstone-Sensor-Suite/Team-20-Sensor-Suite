###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         10/Mar/2021  21:28:33
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        C:\Users\Yesoooof\Documents\GitHub\Team-20-Sensor-Suite\Firmware\On-chip
#        App\onchipsdk-master\src\app\02-i2c\i2c_app.c
#    Command line =
#        -f C:\Users\Yesoooof\AppData\Local\Temp\EW1AA1.tmp
#        ("C:\Users\Yesoooof\Documents\GitHub\Team-20-Sensor-Suite\Firmware\On-chip
#        App\onchipsdk-master\src\app\02-i2c\i2c_app.c" -lcN
#        "C:\Users\Yesoooof\Documents\GitHub\Team-20-Sensor-Suite\Firmware\On-chip
#        App\onchipsdk-master\projects\iar\02-i2c\Debug\List" -o
#        "C:\Users\Yesoooof\Documents\GitHub\Team-20-Sensor-Suite\Firmware\On-chip
#        App\onchipsdk-master\projects\iar\02-i2c\Debug\Obj" --debug
#        --endian=little --cpu=Cortex-M3 --no_path_in_file_macros --enum_is_int
#        -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Normal.h"
#        --preinclude
#        "C:\Users\Yesoooof\Documents\GitHub\Team-20-Sensor-Suite\Firmware\On-chip
#        App\onchipsdk-master\projects\iar\02-i2c\..\all_projects.iarinc" -I
#        "C:\Users\Yesoooof\Documents\GitHub\Team-20-Sensor-Suite\Firmware\On-chip
#        App\onchipsdk-master\projects\iar\02-i2c\..\..\..\src\app\02-i2c\" -I
#        "C:\Users\Yesoooof\Documents\GitHub\Team-20-Sensor-Suite\Firmware\On-chip
#        App\onchipsdk-master\projects\iar\02-i2c\..\..\..\src\app\common\" -I
#        "C:\Users\Yesoooof\Documents\GitHub\Team-20-Sensor-Suite\Firmware\On-chip
#        App\onchipsdk-master\projects\iar\02-i2c\..\..\..\src\inc\" -I
#        "C:\Users\Yesoooof\Documents\GitHub\Team-20-Sensor-Suite\Firmware\On-chip
#        App\onchipsdk-master\projects\iar\02-i2c\..\..\..\src\modules\clilib\"
#        -I
#        "C:\Users\Yesoooof\Documents\GitHub\Team-20-Sensor-Suite\Firmware\On-chip
#        App\onchipsdk-master\projects\iar\02-i2c\..\..\..\src\modules\ip_applib\"
#        -Oh)
#    Locale       =  C
#    List file    =
#        C:\Users\Yesoooof\Documents\GitHub\Team-20-Sensor-Suite\Firmware\On-chip
#        App\onchipsdk-master\projects\iar\02-i2c\Debug\List\i2c_app.lst
#    Object file  =
#        C:\Users\Yesoooof\Documents\GitHub\Team-20-Sensor-Suite\Firmware\On-chip
#        App\onchipsdk-master\projects\iar\02-i2c\Debug\Obj\i2c_app.o
#
###############################################################################

C:\Users\Yesoooof\Documents\GitHub\Team-20-Sensor-Suite\Firmware\On-chip App\onchipsdk-master\src\app\02-i2c\i2c_app.c
      1          /*
      2          Copyright (c) 2013, Dust Networks.  All rights reserved.
      3          */
      4          
      5          #include "dn_common.h"
      6          #include "string.h"
      7          #include "stdio.h"
      8          #include "cli_task.h"
      9          #include "loc_task.h"
     10          #include "dn_system.h"
     11          #include "dn_i2c.h"
     12          #include "dn_exe_hdr.h"
     13          #include "app_task_cfg.h"
     14          #include "Ver.h"
     15          
     16          //=========================== definitions =====================================
     17          
     18          #define I2C_SLAVE_ADDR       0x26
     19          #define I2C_PAYLOAD_LENGTH   4
     20          
     21          //=========================== variables =======================================
     22          
     23          typedef struct {
     24             INT8U                     ledToggleFlag;
     25             dn_ioctl_i2c_transfer_t   i2cTransfer;
     26             OS_STK                    i2cTaskStack[TASK_APP_I2C_STK_SIZE];
     27             INT8U                     i2cBuffer[I2C_PAYLOAD_LENGTH];
     28          } i2c_app_vars_t;
     29          
     30          i2c_app_vars_t     i2c_app_v;
     31          
     32          //=========================== prototypes ======================================
     33          
     34          static void i2cTask(void* unused);
     35          
     36          //=========================== initialization ==================================
     37          
     38          /**
     39          \brief This is the entry point in the application code.
     40          */
     41          int p2_init(void) {
     42             INT8U                   osErr;
     43          
     44             cli_task_init(
     45                "i2c",                                // appName
     46                NULL                                  // cliCmds
     47             );
     48             loc_task_init(
     49                JOIN_NO,                              // fJoin
     50                NETID_NONE,                           // netId
     51                UDPPORT_NONE,                         // udpPort
     52                NULL,                                 // joinedSem
     53                BANDWIDTH_NONE,                       // bandwidth
     54                NULL                                  // serviceSem
     55             );
     56             
     57             // create the I2C task
     58             osErr  = OSTaskCreateExt(
     59                i2cTask,
     60                (void *)0,
     61                (OS_STK*)(&i2c_app_v.i2cTaskStack[TASK_APP_I2C_STK_SIZE-1]),
     62                TASK_APP_I2C_PRIORITY,
     63                TASK_APP_I2C_PRIORITY,
     64                (OS_STK*)i2c_app_v.i2cTaskStack,
     65                TASK_APP_I2C_STK_SIZE,
     66                (void *)0,
     67                OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR
     68             );
     69             ASSERT(osErr==OS_ERR_NONE);
     70             OSTaskNameSet(TASK_APP_I2C_PRIORITY, (INT8U*)TASK_APP_I2C_NAME, &osErr);
     71             ASSERT(osErr==OS_ERR_NONE);
     72             
     73             return 0;
     74          }
     75          
     76          //=========================== I2C task ========================================
     77          
     78          /**
     79          \brief A demo task to show the use of the I2C.
     80          */
     81          static void i2cTask(void* unused) {
     82             dn_error_t                   dnErr;
     83             dn_i2c_open_args_t           i2cOpenArgs;
     84             INT8U                        i;
     85             
     86             //===== open the I2C device
     87             
     88             // wait a bit
     89             OSTimeDly(1000);
     90             
     91             // open the I2C device
     92             i2cOpenArgs.frequency = DN_I2C_FREQ_184_KHZ;
     93             dnErr = dn_open(
     94                DN_I2C_DEV_ID,
     95                &i2cOpenArgs,
     96                sizeof(i2cOpenArgs)
     97             );
     98             ASSERT(dnErr==DN_ERR_NONE); 
     99             
    100             while(1) {
    101                // infinite loop
    102                
    103                //===== step 1. write to I2C slave
    104                
    105                // wait a bit
    106                OSTimeDly(1000);
    107               
    108                // prepare buffer
    109                for (i=0;i<I2C_PAYLOAD_LENGTH;i++) {
    110                   i2c_app_v.i2cBuffer[i]             = 0x00; //prepare write word
    111                }
    112                i2c_app_v.i2cBuffer[3]             = 0x01;
    113                // initialize I2C communication parameters
    114                i2c_app_v.i2cTransfer.slaveAddress    = I2C_SLAVE_ADDR;
    115                i2c_app_v.i2cTransfer.writeBuf        = i2c_app_v.i2cBuffer;
    116                i2c_app_v.i2cTransfer.readBuf         = NULL;
    117                i2c_app_v.i2cTransfer.writeLen        = sizeof(i2c_app_v.i2cBuffer);
    118                i2c_app_v.i2cTransfer.readLen         = 0;
    119                i2c_app_v.i2cTransfer.timeout         = 0xff;
    120                
    121                // initiate transaction
    122                dnErr = dn_ioctl(
    123                   DN_I2C_DEV_ID,
    124                   DN_IOCTL_I2C_TRANSFER,
    125                   &i2c_app_v.i2cTransfer,
    126                   sizeof(i2c_app_v.i2cTransfer)
    127                );
    128                
    129                // print
    130                if (dnErr==DN_ERR_NONE) {
    131                   dnm_ucli_printf("Sent to I2C slave %02x: 0x",I2C_SLAVE_ADDR);
    132                   for (i=0;i<I2C_PAYLOAD_LENGTH;i++) {
    133                      dnm_ucli_printf("%02x",i2c_app_v.i2cBuffer[i]);
    134                   }
    135                   dnm_ucli_printf("\r\n");         
    136                } else {
    137                   dnm_ucli_printf("Unable to write over I2C, err=%d\r\n",dnErr);
    138                }
    139                
    140                //===== step 2. read from I2C slave
    141                
    142                // wait a bit
    143                OSTimeDly(1000);
    144                
    145                // prepare buffer
    146                memset(i2c_app_v.i2cBuffer,0,sizeof(i2c_app_v.i2cBuffer));
    147                
    148                // initialize I2C communication parameters
    149                i2c_app_v.i2cTransfer.slaveAddress    = I2C_SLAVE_ADDR;
    150                i2c_app_v.i2cTransfer.writeBuf        = NULL;           // NULL for read
    151                i2c_app_v.i2cTransfer.readBuf         = i2c_app_v.i2cBuffer;
    152                i2c_app_v.i2cTransfer.writeLen        = 0;
    153                i2c_app_v.i2cTransfer.readLen         = sizeof(i2c_app_v.i2cBuffer);
    154                i2c_app_v.i2cTransfer.timeout         = 0xff;
    155                
    156                // initiate transaction
    157                dnErr = dn_ioctl(
    158                   DN_I2C_DEV_ID,
    159                   DN_IOCTL_I2C_TRANSFER,
    160                   &i2c_app_v.i2cTransfer,
    161                   sizeof(i2c_app_v.i2cTransfer)
    162                );
    163                
    164                // print
    165                if (dnErr==DN_ERR_NONE) {
    166                   dnm_ucli_printf("Received from I2C slave %02x: 0x",I2C_SLAVE_ADDR);
    167                   for (i=0;i<I2C_PAYLOAD_LENGTH;i++) {
    168                      dnm_ucli_printf("%02x",i2c_app_v.i2cBuffer[i]);
    169                   }
    170                   dnm_ucli_printf("\r\n");
    171                } else {
    172                   dnm_ucli_printf("Unable to read over I2C, err=%d\r\n",dnErr);
    173                }
    174             }
    175          }
    176          
    177          //=============================================================================
    178          //=========================== install a kernel header =========================
    179          //=============================================================================
    180          
    181          /**
    182          A kernel header is a set of bytes prepended to the actual binary image of this
    183          application. Thus header is needed for your application to start running.
    184          */
    185          
    186          DN_CREATE_EXE_HDR(DN_VENDOR_ID_NOT_SET,
    187                            DN_APP_ID_NOT_SET,
    188                            VER_MAJOR,
    189                            VER_MINOR,
    190                            VER_PATCH,
    191                            VER_BUILD);

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   i2cTask
        32   -> OSTimeDly
        32   -> assert_handler
        32   -> dn_ioctl
        32   -> dn_open
        32   -> dnm_ucli_printf
      40   p2_init
        40   -> OSTaskCreateExt
        40   -> OSTaskNameSet
        40   -> assert_handler
        40   -> cli_task_init
        40   -> loc_task_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
     108  ?_0
       4  ?_3
      12  ?_4
      28  ?_5
       8  ?_6
       4  ?_7
     268  i2cTask
    1048  i2c_app_v
      32  kernelExeHdr
     116  p2_init

 
 1'048 bytes in section .bss
    32 bytes in section .kernel_exe_hdr
   116 bytes in section .rodata
   448 bytes in section .text
 
   448 bytes of CODE  memory
   148 bytes of CONST memory
 1'048 bytes of DATA  memory

Errors: none
Warnings: none
