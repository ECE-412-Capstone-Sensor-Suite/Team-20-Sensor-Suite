#!/usr/bin/pythonimport sysimport threadingimport timeimport retry:    import serialexcept ImportError:    output  = ''    output += 'Could not load the serial module.\n'    output += 'Please install PySerial from http://pyserial.sourceforge.net/,'    output += 'then run this script again.\n'    raw_input(output)    sys.exit() class UartRaw(threading.Thread):    _BAUDRATE      = 115200                 # the default baudrate used by this module    _PARITY        = serial.PARITY_NONE     # the default parity used by this module    _STOPBITS      = serial.STOPBITS_ONE    # the default stopbits used by this module    def __init__(self):        # initialize parent class        threading.Thread.__init__(self)        self.name                 = 'UARTRAW'                # local variables        self.connected            = False        self.comPort              = ''        self.baudrate             = self._BAUDRATE        self.parity               = self._PARITY        self.stopbits             = self._STOPBITS        self.pyserialHandler      = ''        self.busySending          = threading.Lock()        self.receivedFrame            = {}        self.receivedFrame['payload'] = []    def run(self):               while self.connected==True:            try:                # received a byte                try:                    byte = self.pyserialHandler.read(1)                                    except Exception as err:                    # work-around for bug in pyserial                    # https://sourceforge.net/tracker/?func=detail&aid=3591432&group_id=46487&atid=446302                    raise serial.SerialException(str(err))                if not len(byte):                    raise serial.SerialException()                byte = ord(byte)                # Using the value of 0 in the messages to just break up formating, but this assumes that the                # test packets start with 0                if byte == 0:                                    print                    print "uart RX:",                print("{0:02X}".format(byte)),                            except serial.SerialException:                self.connected = False        del self.pyserialHandler    #======================== public ==========================================    def connect(self,comPort):        self.comPort         = comPort        try:            self.pyserialHandler = serial.Serial(port=self.comPort,baudrate=self.baudrate, parity=self.parity, stopbits=self.stopbits)            self.pyserialHandler.setRTS(False)            #self.pyserialHandler.setDTR(False)            print self.pyserialHandler                    except serial.serialutil.SerialException as err:            raise        else:            self.connected = True            self.name      = '{0}_UARTRAW'.format(self.comPort)            self.start()        return self            def setbaudrate(self, baudrate):        self.baudrate = baudrate    def setstopbits(self, stopbits):        self.stopbits = stopbits      def send(self,message):        if not self.connected:            print 'not connected'            return        packetBytes = message        # reconstitute byteArray        byteArray = ''        for byte in packetBytes:            byteArray += chr(byte)            print("{0:02X}".format(byte)),        print              #self.pyserialHandler.setRTS(True)        # send over serial port           with self.busySending:            numWritten = self.pyserialHandler.write(byteArray)        #self.pyserialHandler.setRTS(False)        if numWritten!=len(packetBytes):            print 'wrote '+str(numWritten)+' bytes, expected '+str(len(packetBytes))      def disconnect(self):        if self.connected==True:            self.pyserialHandler.close()        self.comPort         = ''        self.name            = 'UARTRAW'    #======================== support methods for Python "with" statement =====    def __enter__(self):        pass    def __exit__(self, type, value, tb):        self.disconnect()    #======================== main ================================================def main():    _DEFAULT_LEN    = 10     _DEFAULT_DELAY  = 100    print 'uart_app OCFDK Sample application'    uartport = UartRaw()    uartTxLen   = _DEFAULT_LEN    uartTxDelay = _DEFAULT_DELAY    message = []    for i in range(256):        message.append(i)    while True:        command = raw_input('> ')        command = command.strip()        if not command:            continue        try:            if   command.startswith('connect'):                m = re.search('connect\s+(\S+)',command)                comPort = m.group(1)                uartport.connect(comPort)            elif command.startswith('baudrate'):                m = re.search('baudrate\s+(\S+)',command)                baudrate = m.group(1)                uartport.setbaudrate(baudrate)                presend = 1            elif command.startswith('stopbits'):                m = re.search('stopbits\s+(\S+)',command)                stopbits = m.group(1)                stopbitsDict = {}                stopbitsDict['1'] = serial.STOPBITS_ONE                stopbitsDict['2'] = serial.STOPBITS_TWO                uartport.setstopbits(stopbitsDict[stopbits])            elif command.startswith('len'):                m = re.search('len\s+(\d+)',command)                uartTxLen = int(m.group(1))            elif command.startswith('delay'):                m = re.search('delay\s+(\d+)',command)                uartTxDelay = int(m.group(1))            elif command.startswith('tx'):                m = re.search('tx\s+(\d+)',command)                numTx = m.group(1)                print 'Sending {0} UART packets, {1} bytes, delay {2} ms'.format(numTx,uartTxLen,uartTxDelay)                for i in range(int(numTx)):                    print 'uart TX ({0:3d}):'.format(int(numTx)-i),                    uartport.send(message[0:uartTxLen])                    time.sleep(uartTxDelay/1000.0)                print 'done.'            elif command.startswith('exit'):                uartport.disconnect()                sys.exit(0)            elif command.startswith('help'):                output  = []                output += ['Commands:']                output += ['   connect <comPort>']                output += ['   baudrate <bps>']                output += ['   stopbits <stopbits>']                output += ['   len <numBytes>']                output += ['   delay <numMs>']                output += ['   tx <numPackets>']                output += ['   exit']                output  = '\n'.join(output)                print output            else:                print 'unknown command'        except Exception as err:            print 'invalid (err={0})'.format(err)if __name__=='__main__':    main()