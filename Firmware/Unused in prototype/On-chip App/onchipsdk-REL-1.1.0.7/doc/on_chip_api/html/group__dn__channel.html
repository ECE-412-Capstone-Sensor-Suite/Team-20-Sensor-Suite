<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>SmartMesh IP On-Chip API: Channel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logos.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartMesh IP On-Chip API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Components</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__dn__channel.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Channel<div class="ingroups"><a class="el" href="group___services.html">Services</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Software construction used by the libraries to communicate with your application.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Software construction used by the libraries to communicate with your application. </p>
<p>Channels are used extensively for your application to communicate with the SmartMesh <a class="el" href="group___stack.html">Stack</a>, <a class="el" href="group___devices.html">Devices</a> and <a class="el" href="group___services.html">Services</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Your application should only use channels to communicate with stack, devices and services, not as a generic mechanism to communicate between tasks in your application.</dd></dl>
<h1><a class="anchor" id="sec_concept"></a>
Basic Concept</h1>
<p>A channel is a "pipe" for a producer task to send data to a consumer task. What is being sent is treated by the channel as "bytes", so it can be of arbitrary type and length.</p>
<p>There are two types of channels: synchronous and asynchronous.</p>
<p>Transferring data over an asynchronous channel happens as follows:</p>
<ul>
<li>The producer sends some data (by calling <a class="el" href="group__dn__channel.html#ga63e01fcaa2c93d92895a0e5c63304da4" title="Send a message over some asynchronous channel. ">dn_sendAsyncMsg()</a>, <a class="el" href="group__dn__channel.html#ga7e3e04a01ab701ccf30bfaf443dba9db" title="Extended interface for sending asynchronous messages. ">dn_sendAsyncMsgExt()</a>, <a class="el" href="group__dn__channel.html#gafc9b726427b2dd3ed580f6d4c891dad8" title="Send an asynchronous message by type. ">dn_sendAsyncMsgByType()</a> or <a class="el" href="group__dn__channel.html#ga880542117cc48f6503c67674b7a4bd5d" title="Extended interface for sending asynchronous messages, by type. ">dn_sendAsyncMsgExtByType()</a>). The data is copied inside the channel, and the function returns.</li>
<li>The channel holds on to (a copy of) the data sent by the producer, until read by the consumer.</li>
<li>At some arbitrary time, the consumer calls <a class="el" href="group__dn__channel.html#ga5c9c22db91662dafbb18a04bda9bf459" title="Read a message from an asynchronous channel. ">dn_readAsyncMsg</a> to retrieve the data.</li>
</ul>
<p>From the producer's point of view, the transmission is asynchronous since it does not know whether and when the consumer has received the data. If the consumer wants to send back a reply, it needs to use a different channel transmission.</p>
<p>Transferring data over a synchronous channel happens as follows:</p>
<ul>
<li>The producer sends some data (by calling <a class="el" href="group__dn__channel.html#ga3cbcc07d4b6e42a9fb517cf55c4758ba" title="Send a message over a synchronous channel. ">dn_sendSyncMsg()</a>, <a class="el" href="group__dn__channel.html#ga6be5a04856659ec4d73a7ae790a838e3" title="Extended interface for sending synchronous messages. ">dn_sendSyncMsgExt()</a>, <a class="el" href="group__dn__channel.html#gacffabeeeb11009f32e56a2f0923cae21" title="Send a message over a synchronous channel, by type. ">dn_sendSyncMsgByType()</a> or <a class="el" href="group__dn__channel.html#ga5725833f1496db55200cc127ee317afa" title="Extended interface for sending synchronous messages, by type. ">dn_sendSyncMsgExtByType()</a>). The producer is now blocked, i.e. the function does not return immediately.</li>
<li>Some arbitrary time after, the consumer calls the <a class="el" href="group__dn__channel.html#gafed4da4f3c01223171de094517bedcee" title="Read a message from a synchronous channel. ">dn_readSyncMsg()</a>, and receives the data.</li>
<li>Some arbitrary time after, the consumer calls <a class="el" href="group__dn__channel.html#ga0a370facd8333c0d9d5d57963a96419f" title="Send a reply to a synchronous message. ">dn_sendReply()</a>, passing some reply data.</li>
<li>This causes the producer to receive the reply, and to unblock.</li>
<li>Note that if the consumer is the first to call <a class="el" href="group__dn__channel.html#gafed4da4f3c01223171de094517bedcee" title="Read a message from a synchronous channel. ">dn_readSyncMsg()</a>, it will block until the producer initiates the send.</li>
</ul>
<p>From the producer's points of view, the transmission is synchronous since, after the send function returns, it has received a response from the consumer. Of course, since the consumer can choose not to read the channel immediately, or needs some time to process it before sending back a reply, the producer can be blocked for an arbitrary amount of time.</p>
<h1><a class="anchor" id="sec_creation"></a>
Creating a Channel</h1>
<p>Creating a channel is done by calling:</p>
<ul>
<li><a class="el" href="group__dn__channel.html#ga66fb36a8e908131875f66d5708833b2e" title="Create an asynchronous channel. ">dn_createAsyncChannel()</a> to create an asynchronous channel.</li>
<li><a class="el" href="group__dn__channel.html#gaf3e263fb420673bdef6a2abb44fc13d3" title="Create a synchronous channel. ">dn_createSyncChannel()</a> to create an synchronous channel.</li>
</ul>
<p>Both will return a channel descriptor, which your application needs to store and reuse to send/read data over that channel.</p>
<p>An asynchronous channel requires memory to buffer data while waiting for the consumer to read it. The channel uses a uC/OS-II memory block. You have to allocate that memory block using OSMemCreate() (a standard uC/OS-II function), and pass a pointer to it in <a class="el" href="group__dn__channel.html#ga66fb36a8e908131875f66d5708833b2e" title="Create an asynchronous channel. ">dn_createAsyncChannel()</a>.</p>
<h1><a class="anchor" id="sec_types"></a>
Using Message Types</h1>
<p>Message type is an optional feature which allows you to multiplex different stream of data into a single channel. Their use is the same whether you are using synchronous or asynchronous channels.</p>
<p>Each time you send a message through a channel (<a class="el" href="group__dn__channel.html#ga63e01fcaa2c93d92895a0e5c63304da4" title="Send a message over some asynchronous channel. ">dn_sendAsyncMsg()</a>, <a class="el" href="group__dn__channel.html#ga7e3e04a01ab701ccf30bfaf443dba9db" title="Extended interface for sending asynchronous messages. ">dn_sendAsyncMsgExt()</a>, <a class="el" href="group__dn__channel.html#ga3cbcc07d4b6e42a9fb517cf55c4758ba" title="Send a message over a synchronous channel. ">dn_sendSyncMsg()</a>, <a class="el" href="group__dn__channel.html#ga6be5a04856659ec4d73a7ae790a838e3" title="Extended interface for sending synchronous messages. ">dn_sendSyncMsgExt()</a>), you can specify a type (a number). Reading from a channel (<a class="el" href="group__dn__channel.html#ga5c9c22db91662dafbb18a04bda9bf459" title="Read a message from an asynchronous channel. ">dn_readAsyncMsg()</a>, <a class="el" href="group__dn__channel.html#gafed4da4f3c01223171de094517bedcee" title="Read a message from a synchronous channel. ">dn_readSyncMsg()</a>) is unfiltered, i.e. you receive all messages sent over that channel. After receiving a message, you can use the message type to de-multiplex the different streams.</p>
<p>Moreover, if you choose to use message types, you can assign types to a specific channel by calling <a class="el" href="group__dn__channel.html#gae42baab8889803dd65dead999d3e842f" title="Associate a message type with a particular channel. ">dn_registerChannel()</a>, and then use <a class="el" href="group__dn__channel.html#gafc9b726427b2dd3ed580f6d4c891dad8" title="Send an asynchronous message by type. ">dn_sendAsyncMsgByType()</a> and <a class="el" href="group__dn__channel.html#ga5725833f1496db55200cc127ee317afa" title="Extended interface for sending synchronous messages, by type. ">dn_sendSyncMsgExtByType()</a> to send message by type, without having to look up which channel corresponds to that message type beforehand.</p>
<p>The SmartMesh stack uses message types internally when sending notifications to your application.</p>
<h1><a class="anchor" id="sec_prefix"></a>
Using Messages Prefixes</h1>
<p>The "extended" version of the send functions (<a class="el" href="group__dn__channel.html#ga7e3e04a01ab701ccf30bfaf443dba9db" title="Extended interface for sending asynchronous messages. ">dn_sendAsyncMsgExt()</a>, <a class="el" href="group__dn__channel.html#ga880542117cc48f6503c67674b7a4bd5d" title="Extended interface for sending asynchronous messages, by type. ">dn_sendAsyncMsgExtByType()</a>, <a class="el" href="group__dn__channel.html#ga6be5a04856659ec4d73a7ae790a838e3" title="Extended interface for sending synchronous messages. ">dn_sendSyncMsgExt()</a> and <a class="el" href="group__dn__channel.html#ga5725833f1496db55200cc127ee317afa" title="Extended interface for sending synchronous messages, by type. ">dn_sendSyncMsgExtByType()</a>) allow your application to send a message prefix together with a message. The use of this optional feature is the same whether you are using synchronous or asynchronous channels.</p>
<p>When calling the "extended" send functions, you are passing a message prefix and a message. Both are treated as "bytes" by the channel and can therefore be of arbitrary size and type. The channel will prepend the message with the message prefix during the send function, and deliver the resulting concatenated message to the consumer. The consumer cannot distinguish whether the producer used the "extended" send function or not.</p>
<h1><a class="anchor" id="sec_size"></a>
Maximum Message Size</h1>
<p>The message size is the sum of the number of bytes of the message prefix and of the message. The maximum message size depends on the type of channel you are using.</p>
<p>There is no limit on the message size when using synchronous channels. Note that both the producer and the consumer need to allocate memory for that message, since the channel copies the data from the producer to the consumer.</p>
<p>When using asynchronous channels, the maximum message size depends on the size of the memory block you choose when creating the uC/OS-II memory partition (the <code>blksize</code> parameter of the OSMemCreate() function). The channel adds a header in front of the message of type <a class="el" href="structdn__chan__msg__hdr__t.html" title="Header of the raw message exchanged over a channel. ">dn_chan_msg_hdr_t</a>. The maximum message size is therefore <code>blksize-sizeof(<a class="el" href="structdn__chan__msg__hdr__t.html" title="Header of the raw message exchanged over a channel. ">dn_chan_msg_hdr_t</a>)</code>. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdn__chan__msg__hdr__t.html">dn_chan_msg_hdr_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header of the raw message exchanged over a channel.  <a href="structdn__chan__msg__hdr__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Defines</h2></td></tr>
<tr class="memitem:gae2974a964e12b53795abd3ebe8065b57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#gae2974a964e12b53795abd3ebe8065b57">DN_CH_TIMEOUT_NEVER</a></td></tr>
<tr class="memdesc:gae2974a964e12b53795abd3ebe8065b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Never time out.  <a href="#gae2974a964e12b53795abd3ebe8065b57">More...</a><br/></td></tr>
<tr class="separator:gae2974a964e12b53795abd3ebe8065b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6a2c29a6cbe29911dc494b8f6a5e74e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#gae6a2c29a6cbe29911dc494b8f6a5e74e">DN_CH_INVALID_NUM</a></td></tr>
<tr class="memdesc:gae6a2c29a6cbe29911dc494b8f6a5e74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid channel number.  <a href="#gae6a2c29a6cbe29911dc494b8f6a5e74e">More...</a><br/></td></tr>
<tr class="separator:gae6a2c29a6cbe29911dc494b8f6a5e74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb73d12de5b198771fd696743506325e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#gadb73d12de5b198771fd696743506325e">DN_CH_MSG_DATA</a>(m)</td></tr>
<tr class="memdesc:gadb73d12de5b198771fd696743506325e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the data portion of a raw message.  <a href="#gadb73d12de5b198771fd696743506325e">More...</a><br/></td></tr>
<tr class="separator:gadb73d12de5b198771fd696743506325e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de828794e30dd28379cb638559e8d9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#ga2de828794e30dd28379cb638559e8d9e">DN_CH_MSG_TYPE</a>(m)</td></tr>
<tr class="memdesc:ga2de828794e30dd28379cb638559e8d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the type of a raw message.  <a href="#ga2de828794e30dd28379cb638559e8d9e">More...</a><br/></td></tr>
<tr class="separator:ga2de828794e30dd28379cb638559e8d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cb2543fb2be2757dd34212d5a05c3c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#ga0cb2543fb2be2757dd34212d5a05c3c6">DN_CH_MSG_LEN</a>(m)</td></tr>
<tr class="memdesc:ga0cb2543fb2be2757dd34212d5a05c3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the length of a raw message.  <a href="#ga0cb2543fb2be2757dd34212d5a05c3c6">More...</a><br/></td></tr>
<tr class="separator:ga0cb2543fb2be2757dd34212d5a05c3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade6e9dca8029fda9015551f2fbd8707e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#gade6e9dca8029fda9015551f2fbd8707e">DN_CH_ASYNC_RXBUF_SIZE</a>(msize)</td></tr>
<tr class="memdesc:gade6e9dca8029fda9015551f2fbd8707e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pool size for receiving async messages should have space for a <a class="el" href="structdn__chan__msg__hdr__t.html" title="Header of the raw message exchanged over a channel. ">dn_chan_msg_hdr_t</a> structure.  <a href="#gade6e9dca8029fda9015551f2fbd8707e">More...</a><br/></td></tr>
<tr class="separator:gade6e9dca8029fda9015551f2fbd8707e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga8dbd8057e60f8aa0a54e3d9f6d0a5362"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#ga8dbd8057e60f8aa0a54e3d9f6d0a5362">dn_msg_type_t</a> { <br/>
&#160;&#160;<a class="el" href="group__dn__channel.html#gga8dbd8057e60f8aa0a54e3d9f6d0a5362a79d26c33025650ff054b1fd8d0f710a1">DN_MSG_TYPE_CLI_NOTIF</a>, 
<br/>
&#160;&#160;<a class="el" href="group__dn__channel.html#gga8dbd8057e60f8aa0a54e3d9f6d0a5362a3233152d94e6e54541435c78724647b0">DN_MSG_TYPE_CLI_CTRL</a>, 
<br/>
&#160;&#160;<a class="el" href="group__dn__channel.html#gga8dbd8057e60f8aa0a54e3d9f6d0a5362aee8c144dce2fcc68396a3f90ae44b51f">DN_MSG_TYPE_MAC_NOTIF</a>, 
<br/>
&#160;&#160;<a class="el" href="group__dn__channel.html#gga8dbd8057e60f8aa0a54e3d9f6d0a5362ad7df1232baf595a3eb1f944c0b8db6af">DN_MSG_TYPE_MAC_CTRL</a>, 
<br/>
&#160;&#160;<a class="el" href="group__dn__channel.html#gga8dbd8057e60f8aa0a54e3d9f6d0a5362a0891fcc77d14ac297a1a4edde08a6800">DN_MSG_TYPE_NET_NOTIF</a>, 
<br/>
&#160;&#160;<a class="el" href="group__dn__channel.html#gga8dbd8057e60f8aa0a54e3d9f6d0a5362a1b48b1680c7d22da8d0d7286d95aae0d">DN_MSG_TYPE_NET_CTRL</a>, 
<br/>
&#160;&#160;<a class="el" href="group__dn__channel.html#gga8dbd8057e60f8aa0a54e3d9f6d0a5362a7882c0103a8b2a6dc23374126d5ffda1">DN_MSG_TYPE_UART_NOTIF</a>, 
<br/>
&#160;&#160;<a class="el" href="group__dn__channel.html#gga8dbd8057e60f8aa0a54e3d9f6d0a5362ab49c188af81cff22d96f372008640310">DN_MSG_TYPE_UART_EVENTS</a>, 
<br/>
&#160;&#160;<a class="el" href="group__dn__channel.html#gga8dbd8057e60f8aa0a54e3d9f6d0a5362a8974c4d1a6e3d4eeae4991a3f2624efb">DN_MSG_TYPE_UART_TX_CTRL</a>, 
<br/>
&#160;&#160;<a class="el" href="group__dn__channel.html#gga8dbd8057e60f8aa0a54e3d9f6d0a5362aefe8b4e9d9755fc338cbfab787591953">DN_MSG_TYPE_TIMEPIN_NOTIF</a>, 
<br/>
&#160;&#160;<a class="el" href="group__dn__channel.html#gga8dbd8057e60f8aa0a54e3d9f6d0a5362a32b78c24818d7e8cb6994209b64677b9">DN_MSG_TYPE_GPIO_NOTIF</a>, 
<br/>
&#160;&#160;<a class="el" href="group__dn__channel.html#gga8dbd8057e60f8aa0a54e3d9f6d0a5362ad0ba9a311e392a1723c140100af408b6">DN_MSG_TYPE_RADIOTEST</a>, 
<br/>
&#160;&#160;<a class="el" href="group__dn__channel.html#gga8dbd8057e60f8aa0a54e3d9f6d0a5362a0b15f011433c52e401e17b6e9dcd1cb5">DN_MSG_TYPE_REQTIME_NOTIF</a>, 
<br/>
&#160;&#160;<a class="el" href="group__dn__channel.html#gga8dbd8057e60f8aa0a54e3d9f6d0a5362aa68cbc744ec928fd9e88437acf3adc94">DN_MSG_TYPE_LAST</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga8dbd8057e60f8aa0a54e3d9f6d0a5362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message types for channel communication.  <a href="group__dn__channel.html#ga8dbd8057e60f8aa0a54e3d9f6d0a5362">More...</a><br/></td></tr>
<tr class="separator:ga8dbd8057e60f8aa0a54e3d9f6d0a5362"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gacab5346246ac4efb7b171cfd40ed1be0"><td class="memItemLeft" align="right" valign="top">typedef INT8S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a></td></tr>
<tr class="memdesc:gacab5346246ac4efb7b171cfd40ed1be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel descriptor.  <a href="#gacab5346246ac4efb7b171cfd40ed1be0">More...</a><br/></td></tr>
<tr class="separator:gacab5346246ac4efb7b171cfd40ed1be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Channel administration</h2></td></tr>
<tr class="memitem:gae42baab8889803dd65dead999d3e842f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#gae42baab8889803dd65dead999d3e842f">dn_registerChannel</a> (<a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> chDesc, INT32U msgType)</td></tr>
<tr class="memdesc:gae42baab8889803dd65dead999d3e842f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a message type with a particular channel.  <a href="#gae42baab8889803dd65dead999d3e842f">More...</a><br/></td></tr>
<tr class="separator:gae42baab8889803dd65dead999d3e842f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga357b479768ada8a9ea7f42503f9bcb38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#ga357b479768ada8a9ea7f42503f9bcb38">dn_getChannelDesc</a> (INT32U msgType, <a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> *desc)</td></tr>
<tr class="memdesc:ga357b479768ada8a9ea7f42503f9bcb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the channel descriptor associated with some message type.  <a href="#ga357b479768ada8a9ea7f42503f9bcb38">More...</a><br/></td></tr>
<tr class="separator:ga357b479768ada8a9ea7f42503f9bcb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82442168b165a93208e2793db260b010"><td class="memItemLeft" align="right" valign="top">OS_EVENT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#ga82442168b165a93208e2793db260b010">dn_getChanEmptySem</a> (<a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> chDesc)</td></tr>
<tr class="memdesc:ga82442168b165a93208e2793db260b010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the "isEmpty" semaphore associated with a channel.  <a href="#ga82442168b165a93208e2793db260b010">More...</a><br/></td></tr>
<tr class="separator:ga82442168b165a93208e2793db260b010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cb7e74af13ea7d96c5831670bc29915"><td class="memItemLeft" align="right" valign="top">INT32S&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#ga1cb7e74af13ea7d96c5831670bc29915">dn_getMsgCnt</a> (<a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> chDesc)</td></tr>
<tr class="memdesc:ga1cb7e74af13ea7d96c5831670bc29915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of pending messages in a channel.  <a href="#ga1cb7e74af13ea7d96c5831670bc29915">More...</a><br/></td></tr>
<tr class="separator:ga1cb7e74af13ea7d96c5831670bc29915"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Asynchronous channels</h2></td></tr>
<tr class="memitem:ga66fb36a8e908131875f66d5708833b2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#ga66fb36a8e908131875f66d5708833b2e">dn_createAsyncChannel</a> (OS_MEM *pMem, <a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> *desc)</td></tr>
<tr class="memdesc:ga66fb36a8e908131875f66d5708833b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an asynchronous channel.  <a href="#ga66fb36a8e908131875f66d5708833b2e">More...</a><br/></td></tr>
<tr class="separator:ga66fb36a8e908131875f66d5708833b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e01fcaa2c93d92895a0e5c63304da4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#ga63e01fcaa2c93d92895a0e5c63304da4">dn_sendAsyncMsg</a> (<a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> chDesc, const void *msg, INT32U len, INT32U msgType, BOOLEAN fBlock)</td></tr>
<tr class="memdesc:ga63e01fcaa2c93d92895a0e5c63304da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message over some asynchronous channel.  <a href="#ga63e01fcaa2c93d92895a0e5c63304da4">More...</a><br/></td></tr>
<tr class="separator:ga63e01fcaa2c93d92895a0e5c63304da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e3e04a01ab701ccf30bfaf443dba9db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#ga7e3e04a01ab701ccf30bfaf443dba9db">dn_sendAsyncMsgExt</a> (<a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> chDesc, const void *msg, INT32U msgLen, const void *msgOvrhd, INT8U msgOvrhdLen, INT32U msgType, BOOLEAN fBlock)</td></tr>
<tr class="memdesc:ga7e3e04a01ab701ccf30bfaf443dba9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended interface for sending asynchronous messages.  <a href="#ga7e3e04a01ab701ccf30bfaf443dba9db">More...</a><br/></td></tr>
<tr class="separator:ga7e3e04a01ab701ccf30bfaf443dba9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc9b726427b2dd3ed580f6d4c891dad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#gafc9b726427b2dd3ed580f6d4c891dad8">dn_sendAsyncMsgByType</a> (const void *msg, INT32U len, INT32U msgType, BOOLEAN fBlock)</td></tr>
<tr class="memdesc:gafc9b726427b2dd3ed580f6d4c891dad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an asynchronous message by type.  <a href="#gafc9b726427b2dd3ed580f6d4c891dad8">More...</a><br/></td></tr>
<tr class="separator:gafc9b726427b2dd3ed580f6d4c891dad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880542117cc48f6503c67674b7a4bd5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#ga880542117cc48f6503c67674b7a4bd5d">dn_sendAsyncMsgExtByType</a> (const void *msg, INT32U msgLen, const void *msgOvrhd, INT8U msgOvrhdLen, INT32U msgType, BOOLEAN fBlock)</td></tr>
<tr class="memdesc:ga880542117cc48f6503c67674b7a4bd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended interface for sending asynchronous messages, by type.  <a href="#ga880542117cc48f6503c67674b7a4bd5d">More...</a><br/></td></tr>
<tr class="separator:ga880542117cc48f6503c67674b7a4bd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c9c22db91662dafbb18a04bda9bf459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#ga5c9c22db91662dafbb18a04bda9bf459">dn_readAsyncMsg</a> (<a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> chDesc, void *msg, INT32U *rxLen, INT32U *msgType, INT32U maxLen, INT32U timeout)</td></tr>
<tr class="memdesc:ga5c9c22db91662dafbb18a04bda9bf459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a message from an asynchronous channel.  <a href="#ga5c9c22db91662dafbb18a04bda9bf459">More...</a><br/></td></tr>
<tr class="separator:ga5c9c22db91662dafbb18a04bda9bf459"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Synchronous channels</h2></td></tr>
<tr class="memitem:gaf3e263fb420673bdef6a2abb44fc13d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#gaf3e263fb420673bdef6a2abb44fc13d3">dn_createSyncChannel</a> (<a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> *desc)</td></tr>
<tr class="memdesc:gaf3e263fb420673bdef6a2abb44fc13d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a synchronous channel.  <a href="#gaf3e263fb420673bdef6a2abb44fc13d3">More...</a><br/></td></tr>
<tr class="separator:gaf3e263fb420673bdef6a2abb44fc13d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cbcc07d4b6e42a9fb517cf55c4758ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#ga3cbcc07d4b6e42a9fb517cf55c4758ba">dn_sendSyncMsg</a> (<a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> chDesc, const void *msg, INT32U len, INT32U msgType, void *rsp, INT32U maxRspLen, INT32U *rspLen)</td></tr>
<tr class="memdesc:ga3cbcc07d4b6e42a9fb517cf55c4758ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message over a synchronous channel.  <a href="#ga3cbcc07d4b6e42a9fb517cf55c4758ba">More...</a><br/></td></tr>
<tr class="separator:ga3cbcc07d4b6e42a9fb517cf55c4758ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6be5a04856659ec4d73a7ae790a838e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#ga6be5a04856659ec4d73a7ae790a838e3">dn_sendSyncMsgExt</a> (<a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> chDesc, const void *msg, INT32U msgLen, const void *msgPrefix, INT8U prefixLen, INT32U msgType, void *rsp, INT32U maxRspLen, INT32U *rspLen)</td></tr>
<tr class="memdesc:ga6be5a04856659ec4d73a7ae790a838e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended interface for sending synchronous messages.  <a href="#ga6be5a04856659ec4d73a7ae790a838e3">More...</a><br/></td></tr>
<tr class="separator:ga6be5a04856659ec4d73a7ae790a838e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacffabeeeb11009f32e56a2f0923cae21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#gacffabeeeb11009f32e56a2f0923cae21">dn_sendSyncMsgByType</a> (const void *msg, INT32U len, INT32U msgType, void *rsp, INT32U maxRspLen, INT32U *rspLen)</td></tr>
<tr class="memdesc:gacffabeeeb11009f32e56a2f0923cae21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message over a synchronous channel, by type.  <a href="#gacffabeeeb11009f32e56a2f0923cae21">More...</a><br/></td></tr>
<tr class="separator:gacffabeeeb11009f32e56a2f0923cae21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5725833f1496db55200cc127ee317afa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#ga5725833f1496db55200cc127ee317afa">dn_sendSyncMsgExtByType</a> (const void *msg, INT32U msgLen, const void *msgPrefix, INT8U msgPrefixLen, INT32U msgType, void *rsp, INT32U maxRspLen, INT32U *rspLen)</td></tr>
<tr class="memdesc:ga5725833f1496db55200cc127ee317afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended interface for sending synchronous messages, by type.  <a href="#ga5725833f1496db55200cc127ee317afa">More...</a><br/></td></tr>
<tr class="separator:ga5725833f1496db55200cc127ee317afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafed4da4f3c01223171de094517bedcee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#gafed4da4f3c01223171de094517bedcee">dn_readSyncMsg</a> (<a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> chDesc, void *msg, INT32U *rxLen, INT32U *msgType, INT32U maxLen, INT32U timeout)</td></tr>
<tr class="memdesc:gafed4da4f3c01223171de094517bedcee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a message from a synchronous channel.  <a href="#gafed4da4f3c01223171de094517bedcee">More...</a><br/></td></tr>
<tr class="separator:gafed4da4f3c01223171de094517bedcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a370facd8333c0d9d5d57963a96419f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dn__channel.html#ga0a370facd8333c0d9d5d57963a96419f">dn_sendReply</a> (<a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> chDesc, void *replyMsg, INT32U len)</td></tr>
<tr class="memdesc:ga0a370facd8333c0d9d5d57963a96419f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a reply to a synchronous message.  <a href="#ga0a370facd8333c0d9d5d57963a96419f">More...</a><br/></td></tr>
<tr class="separator:ga0a370facd8333c0d9d5d57963a96419f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Defines</h2>
<a class="anchor" id="gae2974a964e12b53795abd3ebe8065b57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DN_CH_TIMEOUT_NEVER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Never time out. </p>

</div>
</div>
<a class="anchor" id="gae6a2c29a6cbe29911dc494b8f6a5e74e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DN_CH_INVALID_NUM</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalid channel number. </p>

</div>
</div>
<a class="anchor" id="gadb73d12de5b198771fd696743506325e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DN_CH_MSG_DATA</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a pointer to the data portion of a raw message. </p>

</div>
</div>
<a class="anchor" id="ga2de828794e30dd28379cb638559e8d9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DN_CH_MSG_TYPE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the type of a raw message. </p>

</div>
</div>
<a class="anchor" id="ga0cb2543fb2be2757dd34212d5a05c3c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DN_CH_MSG_LEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the length of a raw message. </p>

</div>
</div>
<a class="anchor" id="gade6e9dca8029fda9015551f2fbd8707e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DN_CH_ASYNC_RXBUF_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msize</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The pool size for receiving async messages should have space for a <a class="el" href="structdn__chan__msg__hdr__t.html" title="Header of the raw message exchanged over a channel. ">dn_chan_msg_hdr_t</a> structure. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gacab5346246ac4efb7b171cfd40ed1be0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef INT8S <a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Channel descriptor. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga8dbd8057e60f8aa0a54e3d9f6d0a5362"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__dn__channel.html#ga8dbd8057e60f8aa0a54e3d9f6d0a5362">dn_msg_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Message types for channel communication. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga8dbd8057e60f8aa0a54e3d9f6d0a5362a79d26c33025650ff054b1fd8d0f710a1"></a>DN_MSG_TYPE_CLI_NOTIF</em>&nbsp;</td><td class="fielddoc">
<p>CLI notification. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8dbd8057e60f8aa0a54e3d9f6d0a5362a3233152d94e6e54541435c78724647b0"></a>DN_MSG_TYPE_CLI_CTRL</em>&nbsp;</td><td class="fielddoc">
<p>CLI control. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8dbd8057e60f8aa0a54e3d9f6d0a5362aee8c144dce2fcc68396a3f90ae44b51f"></a>DN_MSG_TYPE_MAC_NOTIF</em>&nbsp;</td><td class="fielddoc">
<p>MAC notification. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8dbd8057e60f8aa0a54e3d9f6d0a5362ad7df1232baf595a3eb1f944c0b8db6af"></a>DN_MSG_TYPE_MAC_CTRL</em>&nbsp;</td><td class="fielddoc">
<p>MAC control. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8dbd8057e60f8aa0a54e3d9f6d0a5362a0891fcc77d14ac297a1a4edde08a6800"></a>DN_MSG_TYPE_NET_NOTIF</em>&nbsp;</td><td class="fielddoc">
<p>NET notification. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8dbd8057e60f8aa0a54e3d9f6d0a5362a1b48b1680c7d22da8d0d7286d95aae0d"></a>DN_MSG_TYPE_NET_CTRL</em>&nbsp;</td><td class="fielddoc">
<p>NET control. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8dbd8057e60f8aa0a54e3d9f6d0a5362a7882c0103a8b2a6dc23374126d5ffda1"></a>DN_MSG_TYPE_UART_NOTIF</em>&nbsp;</td><td class="fielddoc">
<p>UART packet notification. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8dbd8057e60f8aa0a54e3d9f6d0a5362ab49c188af81cff22d96f372008640310"></a>DN_MSG_TYPE_UART_EVENTS</em>&nbsp;</td><td class="fielddoc">
<p>UART event notifications. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8dbd8057e60f8aa0a54e3d9f6d0a5362a8974c4d1a6e3d4eeae4991a3f2624efb"></a>DN_MSG_TYPE_UART_TX_CTRL</em>&nbsp;</td><td class="fielddoc">
<p>UART control. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8dbd8057e60f8aa0a54e3d9f6d0a5362aefe8b4e9d9755fc338cbfab787591953"></a>DN_MSG_TYPE_TIMEPIN_NOTIF</em>&nbsp;</td><td class="fielddoc">
<p>Time pin notification. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8dbd8057e60f8aa0a54e3d9f6d0a5362a32b78c24818d7e8cb6994209b64677b9"></a>DN_MSG_TYPE_GPIO_NOTIF</em>&nbsp;</td><td class="fielddoc">
<p>GPIO notification. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8dbd8057e60f8aa0a54e3d9f6d0a5362ad0ba9a311e392a1723c140100af408b6"></a>DN_MSG_TYPE_RADIOTEST</em>&nbsp;</td><td class="fielddoc">
<p>Radio-test notification. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8dbd8057e60f8aa0a54e3d9f6d0a5362a0b15f011433c52e401e17b6e9dcd1cb5"></a>DN_MSG_TYPE_REQTIME_NOTIF</em>&nbsp;</td><td class="fielddoc">
<p>Notification to request time. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8dbd8057e60f8aa0a54e3d9f6d0a5362aa68cbc744ec928fd9e88437acf3adc94"></a>DN_MSG_TYPE_LAST</em>&nbsp;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae42baab8889803dd65dead999d3e842f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dn_registerChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a>&#160;</td>
          <td class="paramname"><em>chDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>msgType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate a message type with a particular channel. </p>
<dl class="section note"><dt>Note</dt><dd>Multiple message types may be registered to a single channel, however, each message type may not be registered to more than one channel.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chDesc</td><td>Descriptor corresponding to the channel that should receive messages of the type specified in the <code>msgType</code> parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgType</td><td>Message type to associate with the given channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error. ">DN_ERR_NONE</a> if the operation completed successfully. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if <code>chDesc</code> is not a valid channel descriptor. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if <code>msgType</code> is not a valid message type. </dd></dl>

</div>
</div>
<a class="anchor" id="ga357b479768ada8a9ea7f42503f9bcb38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dn_getChannelDesc </td>
          <td>(</td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>msgType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the channel descriptor associated with some message type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msgType</td><td>The message type of interest. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>Location to write the channel descriptor to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error. ">DN_ERR_NONE</a> if a channel was found, and written to the location pointed to by the <code>msgType</code> parameter. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if <code>msgType</code> is not a valid message type. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if no channel was found associated with message type <code>msgType</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga82442168b165a93208e2793db260b010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OS_EVENT * dn_getChanEmptySem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a>&#160;</td>
          <td class="paramname"><em>chDesc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the "isEmpty" semaphore associated with a channel. </p>
<p>Each channel (both synchronous and asynchronous) contain a semaphore which is posted when the channel transitions from empty to non-empty.</p>
<p>This function allows you to have access to the semaphore directly, which might be useful when using uC/OS-II functions such as OSEventPendMulti.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chDesc</td><td>Descriptor of the channel of interest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the semaphore. </dd>
<dd>
<code>NULL</code> if the channel could not be found. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1cb7e74af13ea7d96c5831670bc29915"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32S dn_getMsgCnt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a>&#160;</td>
          <td class="paramname"><em>chDesc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of pending messages in a channel. </p>
<p>This applies to both synchronous and asynchronous channels.</p>
<p>A channel contains a buffer of messages which were sent by producers, but not retrieved by consumers yet. Your application can use this function to retrieve the number of those messages, for example to determine whether a subsequent call a read function will block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chDesc</td><td>Descriptor of the channel of interest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of pending messages. This is <code>0</code> if no messages are pending. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> (a negative number) if <code>chDesc</code> is not a valid channel descriptor. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> (a negative number) if this function can not complete successfully. </dd></dl>

</div>
</div>
<a class="anchor" id="ga66fb36a8e908131875f66d5708833b2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dn_createAsyncChannel </td>
          <td>(</td>
          <td class="paramtype">OS_MEM *&#160;</td>
          <td class="paramname"><em>pMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an asynchronous channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pMem</td><td>Pointer to a uC/OS-II memory allocation. The OS_MEM object must have already been created by the user, and the number of blocks in the OS_MEM object will determine the size of the channel queue. The application should not directly use the allocation for other uses. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>Location to write the channel descritor to after is has been created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error. ">DN_ERR_NONE</a> if the channel is created successfully. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if the <code>pMem</code> parameters does not point to a valid memory allocator. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a396dce3863e06159b8f80c2334d9ccd1" title="(-2) No resources. ">DN_ERR_NO_RESOURCES</a> if allocating the channel failed because not enough resources are available. </dd></dl>

</div>
</div>
<a class="anchor" id="ga63e01fcaa2c93d92895a0e5c63304da4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dn_sendAsyncMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a>&#160;</td>
          <td class="paramname"><em>chDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>msgType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN&#160;</td>
          <td class="paramname"><em>fBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message over some asynchronous channel. </p>
<p>When your application sends a message over an asynchronous channel, this function will return when the message is queued in the channel (see <code>fBlock</code> parameter). It will not, however, block until the consumer processes the message, and therefore does not return a response from the consumer.</p>
<dl class="section note"><dt>Note</dt><dd>When calling this function, the asynchronous channel will create a <b>copy</b> of the message you will send, and deliver that to the consumer. This means that, once you have called this function, you're free to reuse or modify the location in memory holding the message you just sent.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chDesc</td><td>Descriptor of the asynchronous channel to send the message over. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to the message to be sent. This can be data of any type, and is treated as a series of bytes by the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes in the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgType</td><td>Type of the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fBlock</td><td>If <code>FALSE</code>, this function returns <a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a396dce3863e06159b8f80c2334d9ccd1" title="(-2) No resources. ">DN_ERR_NO_RESOURCES</a> immediately if the channel queue is full. If <code>TRUE</code>, this function blocks until the message is queued up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error. ">DN_ERR_NONE</a> if the message is sent successfully. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if <code>chDesc</code> is not a valid channel descriptor. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if you are trying to sent too many bytes. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a396dce3863e06159b8f80c2334d9ccd1" title="(-2) No resources. ">DN_ERR_NO_RESOURCES</a> if <code>fBlock</code> is not set and channel full. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e3e04a01ab701ccf30bfaf443dba9db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dn_sendAsyncMsgExt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a>&#160;</td>
          <td class="paramname"><em>chDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>msgLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msgPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT8U&#160;</td>
          <td class="paramname"><em>msgPrefixLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>msgType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN&#160;</td>
          <td class="paramname"><em>fBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extended interface for sending asynchronous messages. </p>
<dl class="section note"><dt>Note</dt><dd>If applicable, use the (simpler) <a class="el" href="group__dn__channel.html#ga63e01fcaa2c93d92895a0e5c63304da4" title="Send a message over some asynchronous channel. ">dn_sendAsyncMsg()</a> and <a class="el" href="group__dn__channel.html#gafc9b726427b2dd3ed580f6d4c891dad8" title="Send an asynchronous message by type. ">dn_sendAsyncMsgByType()</a> functions.</dd></dl>
<p>Allows the message to be formed by two pieces: a prefix and a message. The channel concatenates the prefix and the message into a single message, which it delivers to the consumer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chDesc</td><td>Descriptor of the asynchronous channel to send the data over. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to the message to be sent. This can be data of any type, and is treated as a series of bytes by this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgLen</td><td>Number of bytes in the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPrefix</td><td>Pointer to the prefix to be pre-pended to the message. This can be data of any type, and is treated as a series of bytes by this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPrefixLen</td><td>Number of bytes in the prefix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgType</td><td>Type of the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fBlock</td><td>If <code>FALSE</code>, this function returns <a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a396dce3863e06159b8f80c2334d9ccd1" title="(-2) No resources. ">DN_ERR_NO_RESOURCES</a> immediately if the channel queue is full. If <code>TRUE</code>, this function blocks until the message is queued up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error. ">DN_ERR_NONE</a> if the message is sent successfully. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if <code>chDesc</code> is not a valid channel descriptor. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if you are trying to sent too many bytes. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a396dce3863e06159b8f80c2334d9ccd1" title="(-2) No resources. ">DN_ERR_NO_RESOURCES</a> if <code>fBlock</code> is not set and channel full. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc9b726427b2dd3ed580f6d4c891dad8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dn_sendAsyncMsgByType </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>msgType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN&#160;</td>
          <td class="paramname"><em>fBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an asynchronous message by type. </p>
<p>This function behaves as <a class="el" href="group__dn__channel.html#ga63e01fcaa2c93d92895a0e5c63304da4" title="Send a message over some asynchronous channel. ">dn_sendAsyncMsg()</a>, but first identifies the channel corresponding to the message type passed in the <code>msgType</code> parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to the message to be sent. This can be data of any type, and is treated as a series of bytes by the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes in the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgType</td><td>Type of the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fBlock</td><td>If <code>FALSE</code>, this function returns <a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a396dce3863e06159b8f80c2334d9ccd1" title="(-2) No resources. ">DN_ERR_NO_RESOURCES</a> immediately if the channel queue is full; If <code>TRUE</code>, this function blocks until the message is queued up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same error code as the <a class="el" href="group__dn__channel.html#ga63e01fcaa2c93d92895a0e5c63304da4" title="Send a message over some asynchronous channel. ">dn_sendAsyncMsg()</a> function. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if no channel can be found which matches the message type passed in the <code>msgType</code> parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="ga880542117cc48f6503c67674b7a4bd5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dn_sendAsyncMsgExtByType </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>msgLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msgPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT8U&#160;</td>
          <td class="paramname"><em>msgPrefixLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>msgType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN&#160;</td>
          <td class="paramname"><em>fBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extended interface for sending asynchronous messages, by type. </p>
<p>This function behaves as <a class="el" href="group__dn__channel.html#ga7e3e04a01ab701ccf30bfaf443dba9db" title="Extended interface for sending asynchronous messages. ">dn_sendAsyncMsgExt()</a>, but first identifies the channel corresponding to the message type passed in the <code>msgType</code> parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to the message to be sent. This can be data of any type, and is treated as a series of bytes by this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgLen</td><td>Number of bytes in the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPrefix</td><td>Pointer to the prefix to be pre-pended to the message. This can be data of any type, and is treated as a series of bytes by this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPrefixLen</td><td>Number of bytes in the prefix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgType</td><td>Type of the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fBlock</td><td>If <code>FALSE</code>, this function returns <a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a396dce3863e06159b8f80c2334d9ccd1" title="(-2) No resources. ">DN_ERR_NO_RESOURCES</a> immediately if the channel queue is full; If <code>TRUE</code>, this function blocks until the message is queued up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same error code as the <a class="el" href="group__dn__channel.html#ga7e3e04a01ab701ccf30bfaf443dba9db" title="Extended interface for sending asynchronous messages. ">dn_sendAsyncMsgExt()</a> function. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if no channel can be found which matches the message type passed in the <code>msgType</code> parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c9c22db91662dafbb18a04bda9bf459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dn_readAsyncMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a>&#160;</td>
          <td class="paramname"><em>chDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U *&#160;</td>
          <td class="paramname"><em>rxLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U *&#160;</td>
          <td class="paramname"><em>msgType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>maxLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a message from an asynchronous channel. </p>
<dl class="section note"><dt>Note</dt><dd>Depending on the setting in <code>timeout</code> parameter, the function can block until a message is received.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chDesc</td><td>Descriptor of the channel to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msg</td><td>Location to write the received message to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rxLen</td><td>Location to write the message length to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msgType</td><td>Location to write the message type to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxLen</td><td>Maximum length of <code>msg</code> buffer. This instructs this function never to write more than <code>maxLen</code> into the location pointed to by the <code>msg</code> parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Number of OS ticks to block while waiting for a message. Use OS_TICKS_PER_SEC to convert this value to seconds. Set to <a class="el" href="group__dn__channel.html#gae2974a964e12b53795abd3ebe8065b57" title="Never time out. ">DN_CH_TIMEOUT_NEVER</a> to block indefinitely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error. ">DN_ERR_NONE</a> if a message was received successfully. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a999633980e64f78acca6af48785390d5" title="(-4) Timeout. ">DN_ERR_TIMEOUT</a> if no message was received by the time the timeout expired. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if <code>chDesc</code> is not a valid channel descriptor. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if the function could not complete. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3e263fb420673bdef6a2abb44fc13d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dn_createSyncChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a> *&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a synchronous channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>Location to write the channel descriptor to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error. ">DN_ERR_NONE</a> if the channel is created successfully. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a396dce3863e06159b8f80c2334d9ccd1" title="(-2) No resources. ">DN_ERR_NO_RESOURCES</a> if allocating the channel failed because not enough resources are available. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3cbcc07d4b6e42a9fb517cf55c4758ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dn_sendSyncMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a>&#160;</td>
          <td class="paramname"><em>chDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>msgType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>maxRspLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U *&#160;</td>
          <td class="paramname"><em>rspLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message over a synchronous channel. </p>
<dl class="section note"><dt>Note</dt><dd>This function blocks until the consumer has read the message and sent a reply.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chDesc</td><td>Descriptor of the synchronous channel to send the message over. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to the message to be sent. This can be data of any type, and is treated as a series of bytes by the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes in the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgType</td><td>Type of the message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rsp</td><td>Location to write the response to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxRspLen</td><td>Maximum size of response buffer. This instructs this function never to write more than <code>maxRspLen</code> bytes at the location pointed to by <code>rsp</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rspLen</td><td>Location to write the response length to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error. ">DN_ERR_NONE</a> if the message is sent successfully. </dd>
<dd>
The same error codes are the <a class="el" href="group__dn__channel.html#ga6be5a04856659ec4d73a7ae790a838e3" title="Extended interface for sending synchronous messages. ">dn_sendSyncMsgExt()</a> function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6be5a04856659ec4d73a7ae790a838e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dn_sendSyncMsgExt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a>&#160;</td>
          <td class="paramname"><em>chDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>msgLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msgPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT8U&#160;</td>
          <td class="paramname"><em>prefixLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>msgType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>maxRspLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U *&#160;</td>
          <td class="paramname"><em>rspLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extended interface for sending synchronous messages. </p>
<dl class="section note"><dt>Note</dt><dd>If applicable, use the (simpler) <a class="el" href="group__dn__channel.html#ga3cbcc07d4b6e42a9fb517cf55c4758ba" title="Send a message over a synchronous channel. ">dn_sendSyncMsg()</a> and <a class="el" href="group__dn__channel.html#gacffabeeeb11009f32e56a2f0923cae21" title="Send a message over a synchronous channel, by type. ">dn_sendSyncMsgByType()</a> functions.</dd>
<dd>
This function blocks until the consumer has read the message and sent a reply.</dd></dl>
<p>Allows the message to be formed by two pieces: a prefix and a message. The channel concatenates the prefix and the message into a single message, which it delivers to the consumer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chDesc</td><td>Descriptor of the synchronous channel to send the message over. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to the message to be sent. This can be data of any type, and is treated as a series of bytes by the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgLen</td><td>Number of bytes in the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPrefix</td><td>Pointer to the message prefix to be sent. This can be data of any type, and is treated as a series of bytes by the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixLen</td><td>Number of bytes in the prefix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgType</td><td>Type of the message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rsp</td><td>Location to write the response to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxRspLen</td><td>Maximum size of response buffer. This instructs this function never to write more than <code>maxRspLen</code> bytes at the location pointed to by <code>rsp</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rspLen</td><td>Location to write the response length to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error. ">DN_ERR_NONE</a> if the message is sent successfully. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if <code>chDesc</code> is not a valid channel descriptor. </dd></dl>

</div>
</div>
<a class="anchor" id="gacffabeeeb11009f32e56a2f0923cae21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dn_sendSyncMsgByType </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>msgType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>maxRspLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U *&#160;</td>
          <td class="paramname"><em>rspLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message over a synchronous channel, by type. </p>
<dl class="section note"><dt>Note</dt><dd>This function blocks until the consumer has read the message and sent a reply.</dd></dl>
<p>This function behaves as <a class="el" href="group__dn__channel.html#ga3cbcc07d4b6e42a9fb517cf55c4758ba" title="Send a message over a synchronous channel. ">dn_sendSyncMsg()</a>, but first identifies the channel corresponding to the message type passed in the <code>msgType</code> parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to the message to be sent. This can be data of any type, and is treated as a series of bytes by the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes in the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgType</td><td>Type of the message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rsp</td><td>Location to write the response to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxRspLen</td><td>Maximum size of response buffer. This instructs this function never to write more than <code>maxRspLen</code> bytes at the location pointed to by <code>rsp</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rspLen</td><td>Location to write the response length to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error. ">DN_ERR_NONE</a> if the message is sent successfully. </dd>
<dd>
The same error codes are the <a class="el" href="group__dn__channel.html#ga3cbcc07d4b6e42a9fb517cf55c4758ba" title="Send a message over a synchronous channel. ">dn_sendSyncMsg()</a> function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5725833f1496db55200cc127ee317afa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dn_sendSyncMsgExtByType </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>msgLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msgPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT8U&#160;</td>
          <td class="paramname"><em>msgPrefixLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>msgType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>maxRspLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U *&#160;</td>
          <td class="paramname"><em>rspLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extended interface for sending synchronous messages, by type. </p>
<dl class="section note"><dt>Note</dt><dd>If applicable, use the (simpler) <a class="el" href="group__dn__channel.html#ga3cbcc07d4b6e42a9fb517cf55c4758ba" title="Send a message over a synchronous channel. ">dn_sendSyncMsg()</a> and <a class="el" href="group__dn__channel.html#gacffabeeeb11009f32e56a2f0923cae21" title="Send a message over a synchronous channel, by type. ">dn_sendSyncMsgByType()</a> functions.</dd>
<dd>
This function blocks until the consumer has read the message and sent a reply.</dd></dl>
<p>This function first identifies the channel corresponding to the message type passed in the <code>msgType</code> parameter.</p>
<p>Allows the message to be formed by two pieces: a prefix and a message. The channel concatenates the prefix and the message into a single message, which it delivers to the consumer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to the message to be sent. This can be data of any type, and is treated as a series of bytes by the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgLen</td><td>Number of bytes in the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPrefix</td><td>Pointer to the message prefix to be sent. This can be data of any type, and is treated as a series of bytes by the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPrefixLen</td><td>Number of bytes in the prefix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgType</td><td>Type of the message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rsp</td><td>Location to write the response to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxRspLen</td><td>Maximum size of response buffer. This instructs this function never to write more than <code>maxRspLen</code> bytes at the location pointed to by <code>rsp</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rspLen</td><td>Location to write the response length to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error. ">DN_ERR_NONE</a> if the message is sent successfully. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if <code>chDesc</code> is not a valid channel descriptor. </dd>
<dd>
The same error codes as <a class="el" href="group__dn__channel.html#ga6be5a04856659ec4d73a7ae790a838e3" title="Extended interface for sending synchronous messages. ">dn_sendSyncMsgExt()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gafed4da4f3c01223171de094517bedcee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dn_readSyncMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a>&#160;</td>
          <td class="paramname"><em>chDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U *&#160;</td>
          <td class="paramname"><em>rxLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U *&#160;</td>
          <td class="paramname"><em>msgType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>maxLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a message from a synchronous channel. </p>
<dl class="section note"><dt>Note</dt><dd>Depending on the setting in the <code>timeout</code> parameter, the function can block until a message is received.</dd></dl>
<p>After reading the message, the consumer MUST send a reply to the producer by using the <a class="el" href="group__dn__channel.html#ga0a370facd8333c0d9d5d57963a96419f" title="Send a reply to a synchronous message. ">dn_sendReply()</a> function. By design, the producer is blocked until the consumer sends that reply.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chDesc</td><td>Descriptor of the channel to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msg</td><td>Location to write the received message to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rxLen</td><td>Location to write the message length to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msgType</td><td>Location to write the message type to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxLen</td><td>Maximum length of <code>msg</code> buffer. This instructs this function never to write more than <code>maxLen</code> bytes into the location pointed to by the <code>msg</code> parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Number of OS ticks to block while waiting for a message. Use OS_TICKS_PER_SEC to convert this value to seconds. Set to <a class="el" href="group__dn__channel.html#gae2974a964e12b53795abd3ebe8065b57" title="Never time out. ">DN_CH_TIMEOUT_NEVER</a> to block indefinitely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error. ">DN_ERR_NONE</a> if a message was received successfully. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a999633980e64f78acca6af48785390d5" title="(-4) Timeout. ">DN_ERR_TIMEOUT</a> if no message was received by the time the timeout expired. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if <code>chDesc</code> is not a valid channel descriptor. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if the function could not complete. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a370facd8333c0d9d5d57963a96419f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dn__errno.html#ga9479eb133dd4d20cf03e2e5c9f2b5167">dn_error_t</a> dn_sendReply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dn__channel.html#gacab5346246ac4efb7b171cfd40ed1be0">CH_DESC</a>&#160;</td>
          <td class="paramname"><em>chDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>replyMsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32U&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a reply to a synchronous message. </p>
<p>After reading a synchronous message, the consumer MUST call this function to send a reply back to the producer. By design, the producer will block until the consumer calls this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chDesc</td><td>Descriptor of the channel to send the reply through. This MUST be the same channel as the one the messages was received over. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replyMsg</td><td>Pointer to the reply message to be sent. This can be data of any type, and is treated as a series of bytes by the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes in the reply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167ab6740c777f27844e1a3e150e549dedec" title="(0) No error. ">DN_ERR_NONE</a> if the reply is sent successfully. </dd>
<dd>
<a class="el" href="group__dn__errno.html#gga9479eb133dd4d20cf03e2e5c9f2b5167a95d9d63acaa33a60da8acab3924ccb63" title="(-3) Invalid value or parameter. ">DN_ERR_INVALID</a> if <code>chDesc</code> is not a valid channel descriptor. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
